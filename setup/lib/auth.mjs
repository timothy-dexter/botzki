import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = join(__dirname, '..', '..');

/**
 * Validate Anthropic API key by making a minimal test call
 */
export async function validateAnthropicKey(key) {
  try {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': key,
        'anthropic-version': '2023-06-01',
      },
      body: JSON.stringify({
        model: 'claude-3-haiku-20240307',
        max_tokens: 1,
        messages: [{ role: 'user', content: 'Hi' }],
      }),
    });

    if (response.status === 401) {
      return { valid: false, error: 'Invalid API key' };
    }
    if (response.status === 400) {
      // Bad request but key is valid (e.g., rate limit, model error)
      return { valid: true };
    }
    if (response.ok) {
      return { valid: true };
    }
    return { valid: false, error: `HTTP ${response.status}` };
  } catch (error) {
    return { valid: false, error: error.message };
  }
}

/**
 * Build auth.json content from API keys
 */
export function buildAuthJson(keys) {
  const auth = {};

  if (keys.anthropic) {
    auth.anthropic = { type: 'api_key', key: keys.anthropic };
  }
  if (keys.openai) {
    auth.openai = { type: 'api_key', key: keys.openai };
  }
  if (keys.groq) {
    auth.groq = { type: 'api_key', key: keys.groq };
  }

  return auth;
}

/**
 * Write auth.json to the repository root
 */
export function writeAuthJson(keys) {
  const auth = buildAuthJson(keys);
  const authPath = join(ROOT_DIR, 'auth.json');
  writeFileSync(authPath, JSON.stringify(auth, null, 2) + '\n');
  return authPath;
}

/**
 * Check if auth.json exists
 */
export function authJsonExists() {
  return existsSync(join(ROOT_DIR, 'auth.json'));
}

/**
 * Read existing auth.json
 */
export function readAuthJson() {
  const authPath = join(ROOT_DIR, 'auth.json');
  if (!existsSync(authPath)) return null;
  try {
    return JSON.parse(readFileSync(authPath, 'utf-8'));
  } catch {
    return null;
  }
}

/**
 * Encode auth.json to base64 for PI_AUTH secret
 */
export function encodeAuthJsonBase64(keys) {
  const auth = buildAuthJson(keys);
  return Buffer.from(JSON.stringify(auth)).toString('base64');
}

/**
 * Check if auth.json is in .gitignore
 */
export function isAuthJsonIgnored() {
  const gitignorePath = join(ROOT_DIR, '.gitignore');
  if (!existsSync(gitignorePath)) return false;
  const content = readFileSync(gitignorePath, 'utf-8');
  return content.includes('auth.json');
}

/**
 * Write .env file for event_handler
 */
export function writeEnvFile(config) {
  const {
    apiKey,
    githubToken,
    githubOwner,
    githubRepo,
    telegramBotToken,
    ghWebhookToken,
    anthropicApiKey,
  } = config;

  const envContent = `# Event Handler Configuration
# Generated by setup wizard

# Authentication key for /webhook endpoint
API_KEY=${apiKey}

# GitHub Personal Access Token (needs repo, workflow scopes)
GH_TOKEN=${githubToken}

# Repository info
GH_OWNER=${githubOwner}
GH_REPO=${githubRepo}

# Telegram bot token from @BotFather
TELEGRAM_BOT_TOKEN=${telegramBotToken || ''}

# Token for GitHub Actions webhook auth (must match GH_WEBHOOK_TOKEN secret)
GH_WEBHOOK_TOKEN=${ghWebhookToken}

# Anthropic API key for Claude chat features
ANTHROPIC_API_KEY=${anthropicApiKey}
`;

  const envPath = join(ROOT_DIR, 'event_handler', '.env');
  writeFileSync(envPath, envContent);
  return envPath;
}
