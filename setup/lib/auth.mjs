import { writeFileSync, readFileSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = join(__dirname, '..', '..');

/**
 * Validate Anthropic API key by making a minimal test call
 */
export async function validateAnthropicKey(key) {
  try {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': key,
        'anthropic-version': '2023-06-01',
      },
      body: JSON.stringify({
        model: 'claude-3-haiku-20240307',
        max_tokens: 1,
        messages: [{ role: 'user', content: 'Hi' }],
      }),
    });

    if (response.status === 401) {
      return { valid: false, error: 'Invalid API key' };
    }
    if (response.status === 400) {
      // Bad request but key is valid (e.g., rate limit, model error)
      return { valid: true };
    }
    if (response.ok) {
      return { valid: true };
    }
    return { valid: false, error: `HTTP ${response.status}` };
  } catch (error) {
    return { valid: false, error: error.message };
  }
}

/**
 * Build auth.json content from API keys
 */
export function buildAuthJson(keys) {
  const auth = {};

  if (keys.anthropic) {
    auth.anthropic = { type: 'api_key', key: keys.anthropic };
  }
  if (keys.openai) {
    auth.openai = { type: 'api_key', key: keys.openai };
  }
  if (keys.groq) {
    auth.groq = { type: 'api_key', key: keys.groq };
  }

  return auth;
}

/**
 * Encode auth.json to base64 for PI_AUTH secret
 */
export function encodeAuthJsonBase64(keys) {
  const auth = buildAuthJson(keys);
  return Buffer.from(JSON.stringify(auth)).toString('base64');
}

/**
 * Write .env file for event_handler
 */
export function writeEnvFile(config) {
  const {
    apiKey,
    githubToken,
    githubOwner,
    githubRepo,
    telegramBotToken,
    telegramWebhookSecret,
    ghWebhookToken,
    anthropicApiKey,
    openaiApiKey,
    telegramChatId,
    telegramVerification,
  } = config;

  const envContent = `# Event Handler Configuration
# Generated by setup wizard

# Authentication key for /webhook endpoint
API_KEY=${apiKey}

# GitHub Personal Access Token (fine-grained: Actions, Contents, Metadata, Pull requests)
GH_TOKEN=${githubToken}

# Repository info
GH_OWNER=${githubOwner}
GH_REPO=${githubRepo}

# Telegram bot token from @BotFather
TELEGRAM_BOT_TOKEN=${telegramBotToken || ''}

# Telegram webhook secret (validates requests are from Telegram)
TELEGRAM_WEBHOOK_SECRET=${telegramWebhookSecret || ''}

# Telegram chat ID (restricts bot to this chat only)
TELEGRAM_CHAT_ID=${telegramChatId || ''}

# Telegram verification code (used during setup, can be removed after)
TELEGRAM_VERIFICATION=${telegramVerification || ''}

# Token for GitHub Actions webhook auth (must match GH_WEBHOOK_TOKEN secret)
GH_WEBHOOK_TOKEN=${ghWebhookToken}

# Anthropic API key for Claude chat features
ANTHROPIC_API_KEY=${anthropicApiKey}

# OpenAI API key for Whisper voice transcription (optional)
OPENAI_API_KEY=${openaiApiKey || ''}
`;

  const envPath = join(ROOT_DIR, 'event_handler', '.env');
  writeFileSync(envPath, envContent);
  return envPath;
}

/**
 * Update a single variable in an existing .env file
 */
export function updateEnvVariable(key, value) {
  const envPath = join(ROOT_DIR, 'event_handler', '.env');
  if (!existsSync(envPath)) {
    throw new Error('.env file not found. Run npm run setup first.');
  }

  let content = readFileSync(envPath, 'utf-8');
  const regex = new RegExp(`^${key}=.*$`, 'm');

  if (regex.test(content)) {
    content = content.replace(regex, `${key}=${value}`);
  } else {
    content = content.trimEnd() + `\n${key}=${value}\n`;
  }

  writeFileSync(envPath, content);
  return envPath;
}
